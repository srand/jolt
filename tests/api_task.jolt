#!/usr/bin/python

import os
import sys
import time
sys.path.append(".")

from testsupport import JoltTest


class TaskApi(JoltTest):
    name = "api/task"

    def test_name(self):
        """
        --- tasks:
        class Explicit(Task):
            name = "explicit1"
        ---
        """
        self.jolt("build explicit1")

    def test_name_inferred(self):
        """
        --- tasks:
        class Inferred(Task):
            pass
        ---
        """
        self.jolt("build inferred")

    def test_name_symbols(self):
        """
        --- tasks:
        class Name(Task):
            name = "a&b/c(d)#"
        ---
        """
        self.jolt("build 'a&b/c(d)#'")

    def test_cacheable(self):
        """
        --- tasks:
        class NonCacheable(Task):
            cacheable = False

        class Cacheable(Task):
            cacheable = True

        class AsReq(Task):
            requires = ["noncacheable"]
        ---
        """
        r = self.jolt("build cacheable")
        self.assertBuild(r, "cacheable")
        r = self.jolt("build cacheable")
        self.assertNoBuild(r, "cacheable")

        r = self.jolt("build noncacheable")
        self.assertBuild(r, "noncacheable")
        r = self.jolt("build noncacheable")
        self.assertBuild(r, "noncacheable")
        self.assertNoArtifact(r)

        r = self.jolt("build asreq")
        self.assertBuild(r, "noncacheable")
        self.assertBuild(r, "asreq")
        r = self.jolt("build asreq")
        self.assertBuild(r, "noncacheable")
        self.assertNoBuild(r, "asreq")

    def test_expires_whenunused(self):
        """
        --- tasks:
        class WhenUnused(Task):
            i = Parameter()
            expires = expires.WhenUnusedFor(seconds=3)

        class WhenUnusedArgs(Task):
            expires = expires.After(weeks=1,days=1,hours=1,minutes=1,seconds=1)

        --- config:
        cachesize = 0G
        ---
        """
        r1 = self.jolt("build whenunused:i=1")
        self.assertArtifact(r1)
        time.sleep(3)

        # This evicts i=1
        r2 = self.jolt("build whenunused:i=2")
        self.assertNoArtifact(r1)
        self.assertArtifact(r2)

        r3 = self.jolt("build whenunused:i=3")
        self.assertArtifact(r2)
        self.assertArtifact(r3)
        time.sleep(1)

        # 1s passed since i=2 was created, now reuse it
        r4 = self.jolt("build whenunused:i=2")
        self.assertNoBuild(r4)
        self.assertArtifact(r2)
        self.assertArtifact(r3)
        time.sleep(1)

        # 2s passed since i=2 was created, reused 1s ago => no eviction
        r4 = self.jolt("build whenunused:i=4")
        self.assertArtifact(r2)
        time.sleep(1)

        # 3s passed since i=2 was created, reused 2s ago => possible eviction
        r4 = self.jolt("build whenunused:i=5")
        time.sleep(1)

        # 4s passed since i=2 was created, reused 3s ago => guaranteed eviction
        r3 = self.jolt("build whenunusedargs")
        self.assertNoArtifact(r2)

    def test_expires_after(self):
        """
        --- tasks:
        class After(Task):
            i = Parameter()
            expires = expires.After(seconds=1)

        class AfterArgs(Task):
            expires = expires.After(weeks=1,days=1,hours=1,minutes=1,seconds=1)
        --- config:
        cachesize = 0G
        ---
        """
        r1 = self.jolt("build after:i=1")
        self.assertArtifact(r1)
        time.sleep(2)

        r2 = self.jolt("build after:i=2")
        self.assertArtifact(r2)
        self.assertNoArtifact(r1)

        r3 = self.jolt("build afterargs")

    def test_expires_after(self):
        """
        --- tasks:
        class NeverArgs(Task):
            expires = expires.Never()
        ---
        """
        self.jolt("build neverargs")

    def test_extends(self):
        """
        --- tasks:
        class Base(Task):
            pass

        class Extended(Task):
            i = Parameter()

            extends = "base"

            def run(self, deps, tools):
                raise_error_if(not deps["base"], "dependency missing")

        class ExtendedExtension(Task):
            i = Parameter()

            extends = "extended:i={{i}}"

            def run(self, deps, tools):
                raise_error_if(not deps[self.extends], "dependency missing")
        ---
        """
        r = self.jolt("build extended:i=1")
        self.assertBuild(r, "base")
        self.assertNoBuild(r, "extended:i=2")
        self.assertNoBuild(r, "extendedextension:i=3")
        r = self.jolt("build extended:i=2")
        self.assertBuild(r, "base")
        self.assertBuild(r, "extended:i=2")
        self.assertNoBuild(r, "extendedextension:i=3")
        self.assertIn("Publication skipped, already in local cache (base", r)
        r = self.jolt("build extendedextension:i=2")
        self.assertBuild(r, "base")
        self.assertIn("Publication skipped, already in local cache (base", r)
        self.assertBuild(r, "extended:i=2")
        self.assertIn("Publication skipped, already in local cache (extended", r)
        self.assertBuild(r, "extendedextension:i=2")
        r = self.jolt("build extendedextension:i=3")
        self.assertBuild(r, "base")
        self.assertIn("Publication skipped, already in local cache (base", r)
        self.assertBuild(r, "extended:i=3")
        self.assertBuild(r, "extendedextension:i=3")

    def test_extends_multiple(self):
        """
        --- tasks:
        class Base1(Task):
            pass

        class Base2(Task):
            pass

        class Extended(Task):
            extends = ["base1", "base2"]
        ---
        """
        with self.assertRaises(Exception, msg="multiple tasks extended"):
            self.jolt("build extended")

    def test_requires(self):
        """
        --- tasks:
        class Base(Task):
            pass

        class Consumer(Task):
            i = Parameter()

            requires = ["base"]

            def run(self, deps, tools):
                raise_error_if(not deps["base"], "dependency missing")

        class Duplicate(Task):
            requires = "base", "base", "base"
        ---
        """
        r = self.jolt("build consumer:i=1")
        self.assertBuild(r, "base")
        r = self.jolt("build consumer:i=2")
        self.assertNoBuild(r, "base")

        r = self.jolt("clean base")
        r = self.jolt("build duplicate -j2")
        t = self.tasks(r)
        self.assertEqual(t, ["base", "duplicate"])

    def test_requires_aliased_name(self):
        """
        --- tasks:
        class Base(Task):
            i = Parameter()

        class Consumer(Task):
            requires = ["alias=base:i=1"]

            def run(self, deps, tools):
                raise_error_if(not deps["alias"], "dependency missing")
        ---
        """
        r = self.build("consumer")
        self.assertBuild(r, "base:i=1")
        self.assertBuild(r, "consumer")

    def test_selfsustained(self):
        """
        --- tasks:
        class A(Task):
            pass

        class B1(Task):
            requires = "a"
            selfsustained = False

        class B2(Task):
            requires = "a"
            selfsustained = True

        class C1(Task):
            requires = "b1"

            def run(self, deps, tools):
                print(deps["a"].path)

        class C2(Task):
            requires = "b2"

            def run(self, deps, tools):
                print(deps["a"].path)

        ---
        """
        self.jolt("build c1")
        with self.assertRaises(Exception, msg="no such dependency"):
            self.jolt("build c2")

        # Because B1 is not selfsustained, A becomes a transitive dependency of C1
        self.jolt("clean a")
        r = self.jolt("build -f c1")
        self.assertBuild(r, "a")
        self.assertBuild(self.lastLog(), "c1")

        # Because B2 is selfsustained, A is not a transitive dependency of C2
        self.jolt("clean a")
        with self.assertRaises(Exception, msg="no such dependency"):
            self.jolt("build -f c2")
        self.assertNoBuild(self.lastLog(), "a")
        self.assertBuild(self.lastLog(), "c2")

    def test_test(self):
        """
        --- tasks:
        from jolt.plugins import allure

        class A(Test):
            def test_error(self):
                raise RuntimeError("Broken A")

            def test_failure(self):
                self.assertEqual(True, False)

        class B(allure.Test):
            def test_error(self):
                raise RuntimeError("Broken B")

            def test_failure(self):
                self.assertEqual(True, False)
        ---
        """
        with self.assertRaises(Exception):
            r = self.jolt("build a --result a.joltxmanifest")
        self.assertContains("a.joltxmanifest", "AssertionError: True != False")
        self.assertContains("a.joltxmanifest", "RuntimeError: Broken A")
        with self.assertRaises(Exception):
            r = self.jolt("build b --result b.joltxmanifest")
        self.assertContains("b.joltxmanifest", "AssertionError: True != False")
        self.assertContains("b.joltxmanifest", "RuntimeError: Broken B")

    def test_weight(self):
        """
        --- tasks:
        class A(Task):
            weight = 3

        class B(Task):
            weight = 1

        class C(Task):
            weight = 2

        ---
        """
        r = self.jolt("build a b c")
        self.assertEqual(self.tasks(r), ["a", "c", "b"])

    def test_param_bool(self):
        """
        --- tasks:
        class Pos(Task):
            arg = BooleanParameter()
            def run(self, deps, tools):
                assert self.arg, "unexpected value"

        class Neg(Task):
            arg = BooleanParameter()
            def run(self, deps, tools):
                assert not self.arg, "unexpected value"
        ---
        """
        with self.assertRaises(Exception):
            self.build("pos:arg=false")
        self.build("pos:arg=true")
        with self.assertRaises(Exception):
            self.build("neg:arg=true")
        self.build("neg:arg=false")


    def test_param_bool_regular(self):
        """
        --- tasks:
        class A(Task):
            arg = Parameter(required=False)
            def run(self, deps, tools):
                assert self.arg, "unexpected value"
        ---
        """
        with self.assertRaises(Exception):
            self.build("a")
        with self.assertRaises(Exception):
            self.build("a:arg=")
        self.build("a:arg=value")

    def test_param_influence(self):
        """
        --- tasks:
        class Influence(Task):
            arg = Parameter()

        class NoInfluence(Task):
            arg = Parameter(influence=False)

        ---
        """
        r = self.build("influence:arg=1 noinfluence:arg=1")
        self.assertBuild(r, "influence:arg=1")
        self.assertBuild(r, "noinfluence:arg=1")

        r = self.build("influence:arg=2 noinfluence:arg=2")
        self.assertBuild(r, "influence:arg=2")
        self.assertNoBuild(r, "noinfluence:arg=2")

    def test_param_explicit_default(self):
        """
        --- tasks:
        class A(Task):
            arg1 = Parameter("1")
            arg2 = Parameter("2")

        class B1(Task):
            # Requires "A" with default parameters
            requires = "a"

        class B2(Task):
            # Also requires "A" with default parameters, but with arg1 explicitly set
            requires = "a:arg1=1"

        class C(Task):
            requires = "b1", "b2"
        ---
        """
        r = self.build("c")
        t = self.tasks(r)
        self.assertEqual(len(t), 4)

    def test_param_list(self):
        """
        --- tasks:
        class A(Task):
            arg = ListParameter(values=["a", "b", "c"])

        class B(Task):
            requires = ["a:arg=a+b"]

            def run(self, deps, tools):
                deps["a:arg=a+b"]
                deps["a:arg=b+a"]
                try:
                    deps["a:arg=c"]
                except:
                    pass
                else:
                    assert False, "invalid dependency found"
        ---
        """
        self.build("b")
        r = self.build("a:arg=b+a")
        self.assertNoBuild(r, "a:arg=b+a")
        with self.assertRaises(Exception, msg="illegal value 'd' assigned to parameter 'arg'"):
            self.build("a:arg=a+b+d")

    def test_param_substitution(self):
        """
        --- tasks:
        class A(Task):
            arg1 = ListParameter(values=["a", "b"])
            arg2 = BooleanParameter()
            arg3 = BooleanParameter()

            def run(self, deps, tools):
                assert tools.expand("{{arg1[0]}}") == "a"
                assert tools.expand("{{arg1[a]}}") == "a"
                assert tools.expand("{{arg1[b]}}") == "None"
                assert tools.expand("{{arg1[a,1,2]}}") == "1"
                assert tools.expand("{{arg1[b,1,2]}}") == "2"

                assert tools.expand("{{arg2}}") == "true"
                assert tools.expand("{{arg2[enabled,disabled]}}") == "enabled"
                assert tools.expand("{{arg3}}") == "false"
                assert tools.expand("{{arg3[enabled,disabled]}}") == "disabled"
        ---
        """
        self.build("a:arg1=a,arg2=true,arg3=false")

    def test_param_list_bad_default(self):
        """
        --- tasks:
        class A(Task):
            arg = ListParameter(["d"], values=["a", "b", "c"])
        ---
        """
        with self.assertRaises(Exception):
            self.build("a")

    def test_param_list_operators(self):
        """
        --- tasks:
        class A(Task):
            arg = ListParameter()
            def run(self, deps, tools):
                assert self.arg == ["a", "b"]
                assert list(reversed(self.arg)) == ["b", "a"]
                assert self.arg[0] == "a"
                assert self.arg[1] == "b"
                assert self.arg[0:] == ["a", "b"]
                assert len(self.arg) == 2
        ---
        """
        self.build("a:arg=b+a")

    def test_param_multiple_instances(self):
        """
        --- tasks:
        class ABase(Task):
            a = Parameter()

        class A(ABase):
            b = Parameter()
            def run(self, deps, tools):
                tools.write_file("{{a}}-{{b}}.txt", "")
        ---
        """
        self.build("a:a=a,b=a a:a=b,b=b")
        with self.tools.cwd(self.ws):
            self.jolt("inspect abase")
            self.assertExists("a-a.txt")
            self.assertExists("b-b.txt")

    def test_param_overridden(self):
        """
        --- tasks:
        class ABase(Task):
            a = Parameter("abase")

        class A(ABase):
            a = Parameter("a")
            def run(self, deps, tools):
                tools.write_file("{{a}}.txt", "")
        ---
        """
        self.build("a")
        with self.tools.cwd(self.ws):
            self.jolt("inspect a")
            self.assertExists("a.txt")

    def test_run_output(self):
        """
        --- tasks:
        class Log(Task):
            def run(self, d, t):
                t.run("echo Hello > /dev/stdout")
                t.run("echo World > /dev/stderr")
        ---
        """
        self.jolt("build log")

    def test_context_indexing(self):
        """
        --- tasks:
        class A(Task):
            a = Parameter()
            b = Parameter("b")
            c = Parameter("c")

        class Pass1(Task):
            requires = ["a:a=1"]

            def run(self, deps, tools):
                print(deps["a:a=1"].path)

        class Pass2(Task):
            requires = ["a:a=1"]

            def run(self, deps, tools):
                print(deps["a:a=1,b=b,c=c"].path)

        class Pass3(Task):
            requires = ["a:a=1"]

            def run(self, deps, tools):
                print(deps["a:a=1,b=b"].path)

        class Pass4(Task):
            requires = ["a:a=1"]

            def run(self, deps, tools):
                print(deps["a:b=b,a=1"].path)

        class Fail1(Task):
            requires = ["a:a=1"]

            def run(self, deps, tools):
                print(deps["a:a=1,b=1"].path)


        class T1(Task):
            requires = ["a"]
        ---
        """
        self.build("pass1 pass2 pass3 pass4")
        with self.assertRaises(Exception, msg="no such dependency"):
            self.build("fail1")

    def test_always_influence(self):
        """
        --- tasks:
        @influence.always
        class A(Task):
            pass
        ---
        """
        r = self.build("a")
        self.assertBuild(r, "a")
        r = self.build("a")
        self.assertBuild(r, "a")

    def test_source_influence(self):
        """
        --- tasks:
        class Helper(object):
            def func(self):
                self.info("value8")

        @influence.source("func", Helper)
        class A(Task):
            def run(self, deps, tools):
                self.info("value1")

            def publish(self, artifact, tools):
                self.info("value2")

            def unpack(self, artifact, tools):
                self.info("value3")

            value4 = "value5"

            def value6(self):
                self.info("value7")
        ---
        """
        artifacts = set()

        r = self.build("a")
        a = self.artifacts(r)
        artifacts.add(a[0])
        self.assertBuild(r, "a")

        for i in range(1, 9):
            with self.tools.cwd(self.ws):
                self.tools.replace_in_file("test.jolt", "value"+str(i), "test"+str(i))
            r = self.build("a")
            self.assertBuild(r, "a")
            a = self.artifacts(r)
            self.assertNotIn(a[0], artifacts)
            artifacts.add(a[0])

        r = self.build("a")
        self.assertNoBuild(r, "a")

    def test_unpack(self):
        """
        --- tasks:
        class UnpackMe(Task):
            def unpack(self, a, t):
                t.run("sleep 1")
                with t.cwd(a.path):
                    t.write_file("unpacked", "yes")

        class Unpacker1(Task):
            requires = "unpackme"

            def run(self, d, t):
                with t.cwd(d["unpackme"].path):
                    assert t.read_file("unpacked") == "yes"

        class Unpacker2(Task):
            requires = "unpackme"
        ---
        """
        self.build("unpacker1")
        self.jolt("clean")
        r = self.build("-j2 unpacker1 unpacker2")
        self.assertBuild(r, "unpacker1")
        self.assertBuild(r, "unpacker2")
        self.assertArtifact(r)

    def test_unpack_fail(self):
        """
        --- tasks:
        once = 0

        class UnpackMe(Task):
            def unpack(self, a, t):
                # Fail once
                global once
                once += 1
                assert once > 1
                t.run("sleep 1")
                with t.cwd(a.path):
                    try:
                        t.read_file("unpacked")
                        assert False, "unpacked exists"
                    except:
                        pass
                    t.write_file("unpacked", "yes")

        class Unpacker1(Task):
            requires = "unpackme"

            def run(self, d, t):
                with t.cwd(d["unpackme"].path):
                    assert t.read_file("unpacked") == "yes"

        class Unpacker2(Task):
            requires = "unpackme"

            def run(self, d, t):
                with t.cwd(d["unpackme"].path):
                    assert t.read_file("unpacked") == "yes"
        ---
        """
        r = self.build("unpackme")
        a = self.artifacts(r)
        self.assertExists(a[0])
        with self.assertRaises(Exception):
            self.build("unpacker1")
        self.assertExists(a[0])

        # Unpackme should not have been discarded due to the error
        r = self.build("unpackme")
        a = self.artifacts(r)
        self.assertNoBuild(r, "unpackme")
        self.assertExists(a[0])

        with self.assertRaises(Exception):
            self.build("-j2 -k unpacker1 unpacker2")
        r = self.lastLog()
        self.assertIn("Execution finished", r)
        self.assertNoArtifact(r)

    def test_download(self):
        """
        --- tasks:
        class Zlib(Download):
            version = Parameter("1.2.12")
            url = "https://zlib.net/zlib-{{version}}.tar.gz"
            collect = [
                ("zlib-{{version}}", "zlib1"),
                dict(files="zlib-{{version}}", dest="zlib2"),
                dict(files="*", dest="zlib3", cwd="zlib-{{version}}")
            ]
        class ZlibArchive(Download):
            extract = False
            version = Parameter("1.2.12")
            url = "https://zlib.net/zlib-{{version}}.tar.gz"

        class PlainText(Download):
            version = Parameter("1.2.12")
            url = ["https://nodejs.org/dist/latest/SHASUMS256.txt"]

        class Multiple(Download):
            version = Parameter("1.2.12")
            url = [
                "https://nodejs.org/dist/latest/SHASUMS256.txt",
                "https://nodejs.org/dist/latest/SHASUMS256.txt.asc",
                "https://nodejs.org/dist/latest/SHASUMS256.txt.sig",
            ]

        ---
        """
        r = self.build("zlib")
        a = self.artifacts(r)
        self.assertExists(os.path.join(a[0], "zlib1", "gzlib.c"))
        self.assertExists(os.path.join(a[0], "zlib2", "gzlib.c"))
        self.assertExists(os.path.join(a[0], "zlib3", "gzlib.c"))

        with self.assertRaises(Exception):
            self.build("zlib:version=invalid")

        r = self.build("zlibarchive")
        a = self.artifacts(r)
        self.assertExists(os.path.join(a[0], "zlib-1.2.12.tar.gz"))

        r = self.build("plaintext")
        a = self.artifacts(r)
        self.assertExists(os.path.join(a[0], "SHASUMS256.txt"))

        r = self.build("multiple")
        a = self.artifacts(r)
        self.assertExists(os.path.join(a[0], "SHASUMS256.txt"))
        self.assertExists(os.path.join(a[0], "SHASUMS256.txt.asc"))
        self.assertExists(os.path.join(a[0], "SHASUMS256.txt.sig"))

    def test_resource(self):
        """
        --- tasks:
        class R1(Resource):
            def acquire(self, artifact, deps, tools, owner):
                print("Acquire R1")
                tools.write_file("r1.lock", "locked")
                assert owner.name == "a", "Incorrect task argument"
                assert False, "Acquisition Error"
            def release(self, artifact, deps, tools):
                print("Release R1")
                tools.write_file("r1.lock", "unlocked")
                assert False, "Unexpected Release"

        class R2(Resource):
            def acquire(self, artifact, deps, tools):
                print("Acquire R2")
                tools.write_file("r2.lock", "locked")
            def release(self, artifact, deps, tools, owner):
                print("Release R2")
                tools.write_file("r2.lock", "unlocked")
                assert owner.name == "a", "Incorrect task argument"

        class A(Task):
            requires = ["r1", "r2"]

            def run(self, deps, tools):
                deps["r1"]
        ---
        """
        with self.assertRaises(Exception, msg="Acquisition Error"):
            self.build("a")
        with self.tools.cwd(self.ws):
            self.assertEqual("locked", self.tools.read_file("r1.lock"))
            self.assertEqual("unlocked", self.tools.read_file("r2.lock"))

    def test_script(self):
        '''
        --- tasks:

        class A(Script):
            """
            ---
            echo -n {{arg}} > {{builddir}}/file.txt
            """
            arg = Parameter()

        class B(Script):
            """
            ---
            set -e
            [ "$(cat {{deps[a:arg=hello].path}}/file.txt)" != "hello" ] && exit 1 || exit 0
            """
            requires = ["a:arg=hello"]

        class C(Script):
            """
            #!/usr/bin/env python3

            print("Hello world")
            """
            requires = ["b"]
        ---
        '''
        self.build("c")

    def test_load_attributes(self):
        """
        --- file: a.py
        {{"attrib": "a"}}
        --- file: b.py
        {{"attrib": "b"}}
        --- tasks:
        @attributes.load("{{param}}.py")
        class A(Task):
            param = Parameter()
            def run(self, deps, tools):
                assert self.attrib == self.param
        ---
        """
        r = self.build("a:param=a")
        self.assertBuild(r, "a:param=a")
        r = self.build("a:param=b")
        self.assertBuild(r, "a:param=b")
        with self.tools.cwd(self.ws):
            self.tools.write_file("a.py", '{{"attrib": "c"}}')
        with self.assertRaises(Exception):
            self.build("a:param=a")

